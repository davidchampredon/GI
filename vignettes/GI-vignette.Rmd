---
title: "GI package: Generation Interval Distributions for Epidemic Models"
author: "David Champredon"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{GI}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The `GI` package implements the theoretical results published in:

[1] Champredon D, Dushoff J. *Intrinsic and realized generation intervals in infectious-disease transmission.* Proceedings of the Royal Society B: Biological Sciences (2015); 282: 20152026. [open access link](http://rspb.royalsocietypublishing.org/content/282/1821/20152026)



## Summary of theoretical framework

The generation interval is the interval between the time when an individual is infected by an infector and the time when this infector was infected. There are three conceptually different generation interval distributions:
 
 * __intrinsic__ generation interval: defines the transmission process in the mathematical model 
 * __forward__ generation interval: observed when a cohort is tracked forward in time to see whom individuals infect
 * __backward__ generation interval: observed when a cohort is investigated by looking backward in time to see
who infected each individual. This generation interval is important when fitting a model to contact tracing data.

For a classical compartmental model (like the SIR model), the generation interval distributions are not explicitly defined and calculating them is not straightforward. 

Similarly, when using a renewal equation to model an epidemic, although the _intrinsic_ generation interval is explicitly defined, both the backward and forward generation intervals are not explicitly defined and calculating them is not straightforward. 

The `GI` package provides easy-to-use functions to calculate the various generation interval distributions.


## Epidemic models implemented

### SEmInR

The SEmInR model is an extension of the popular SEIR model, where $m$ E ("exposed") compartments and $n$ I ("infectious") compartments were introduced artificially in order to have latent and infectious durations distributed more realistically. See [1] for more details on this model.


### RESuDe

Although less popular than compartmental models, it is also possible to model infectious disease transmission with Lotka-Euler's renewal equation. If we note $S_t$ the number of susceptible at time $t$, $I_t$ the _incidence_ at time $t$ (not the prevalence!), $\mathcal{R}_0$ the basic reproduction number, $N$ the constant total population size and $g$ the _intrinsic_ generation interval distribution, we have:
$$ I_t = \mathcal{R}_0 \frac{S_t}{N}\sum_{s=1}^t g(s)\, I_{t-s}$$
$$ S_t = S_{t-1} - I_t$$

Note that this model is defined at _discrete_ times. The susceptible depletion given by the second equation prevent the model to have an exponential growth for ever. This feature defines the label of this model: Renewal Equation with Suceptible Depletion, or "RESuDe".

This model can be slightly more sophisticated and we can introduce:

 * mixing heterogeneity by adding a multiplicative factor $(S_t/N)^\alpha$ for $\alpha\geq 0$
 * intervention effects by adding a multiplicative factor that decreases the force of infection through time $e^{-\kappa t}$ for $\kappa\geq 0$

Hence, the first equation becomes (the second equation, susceptible depletion, is unchanged):
$$ I_t = \mathcal{R}_0 \left(\frac{S_t}{N}\right)^\alpha e^{-\kappa t} \sum_{s=1}^t g(s)\, I_{t-s}$$


## Example to visualize the temporal evolution of GI distributions

### Example with SEmInR model

Let's start by defining the model parameters:
```{r, echo=TRUE,message=FALSE, warning=FALSE}
library(plyr)
library(GI)
latent_mean     <- 5  # Mean duration of latent period (in days)
infectious_mean <- 5  # Mean duration of infectious period (in days)
R0 <- 4
nE <- 3  # Number of artifical 'E' compartments
nI <- 3  # Number of artifical 'E' compartments
horizon <- 100  # make sure simulations last long enough, until the end of the epidemic.
```

Now, let's define the (calendar) times where we want to calculate the forward and backward generation interval distributions (the intrinsic one is constant througout the epidemic):
```{r}
cal.times.fwdbck <- seq(5, horizon-10, by=5)
```
Let's call the `GI.seminr` function to calculate all three generation interval distributions at these calendar times:
```{r,cache=F}
g <- GI.seminr(latent_mean, infectious_mean, R0, nE,nI, cal.times.fwdbck,horizon)
```
The results are stored in list, so lets retrieve them:
```{r}
g.int <- g[['intrinsic']]
g.fwd <- g[['fwd']]
g.bck <- g[['bck']]
t     <- g[['cal.times']]
inc   <- g[['incidence']]
```

In order to understand the temporal evolution of the forward and backward generation interval distributions, let's make some plots. First, we plot the incidence time series generated by the model, as this is one of the fundamental component affecting forward and backward generation interval distributions.

```{r,fig.width=7}
plot(x=t, y=inc, typ='l', 
	 main = "SEmInR simulated incidence",
	 xlab = 'calendar time', ylab='', las=1,lwd=2) ; grid()
```

Now, let's look at the _intrinsic_ generation interval distribution:
```{r,fig.width=7}
plot(g.int$tsi, g.int$density, 
	 typ='l', col='red', lwd=3,
	 xlim = c(0,30),
	 xlab = 'time since infection', ylab ='',yaxt='n',
	 main='Intrinsic generation interval distribution')
```
This intrinsic distribution will __not__ change throughout the epidemic. 

Now, let's look at the forward generation interval distributions, at each calendar times requested in `cal.times.fwdbck`.
```{r,fig.width=7}
plot(x=g.fwd$tsi[[1]], y = g.fwd$density[[1]],
	 main = 'Forward generation interval distribution',
	 xlab = 'time since infection', ylab ='',yaxt='n',
	 xlim = c(0,30), col=rgb(0,0,0,0.2),
	 typ='l',ylim=c(0,0.2))
for(i in 1:length(g.fwd$tsi)) 
	lines(x=g.fwd$tsi[[i]],g.fwd$density[[i]],col=rgb(0,0,0,0.2))
```
Each grey line represents the distribution at a different calendar times, we can see that it is different. 

Apart from the fact that the distribution changes, it is not really clear to see a pattern. So let's plot the mean of the forward generation interval distribution throughout the epidemic (i.e. calendar times):
```{r,fig.width=7}
fbar <- g[['fwd.mean']]
plot(x=cal.times.fwdbck, y=fbar,
	 typ='o', las = 1, 
	 main = 'Mean of the forward generation interval distribution',
	 xlab = 'calendar time', ylab ='')
grid()
```
Each circle is the mean of the distribution calculated at a given calendar time. 

We can do exactly the same analysis for the backward generation interval distribution:
```{r,fig.width=7}
plot(x=g.bck$tsi[[length(g.bck$tsi)]], g.bck$density[[length(g.bck$tsi)]],
	 main = 'Backward generation interval distribution',
	 xlab = 'time since infection', ylab ='', yaxt='n',
	 xlim = c(0,30),
	 typ='l',ylim=c(0,0.2),col=rgb(0,0,0,0.2))
for(i in 1:length(g.bck$tsi)) 
	lines(x=g.bck$tsi[[i]],g.bck$density[[i]],col=rgb(0,0,0,0.2))

bbar <- g[['bck.mean']]
plot(cal.times.fwdbck,bbar,
	 typ='o',las = 1,
	 main = 'Mean of the backward generation interval distribution',
	 xlab = 'calendar time', ylab ='')
grid()
```




### Example with RESuDe model

The exact same analysis as the one done with a SEmInR can be performed with a RESuDe model. The only difference is the way to set up the RESuDe model and the function to call is now `GI.resude` (instead of `GI.seminr`). Also, because RESuDe is _defined_ by explictly giving the _intrinsic_ generation interval distribution (with the `GI_type`, `GI_mean` and `GI_var` parameters), only the forward and backward generation interval distribution are calculated in this case. 

Here is the code to replicate with RESuDe what was done for SEmInR.

```{r,fig.width=7}
library(GI)

### Parameters for RESuDe model
R0 <- 4
horizon <- 100
I.init <- 1
pop_size <- 1e4
alpha <- 0
kappa <- 0
GI_type <- 'pois'  # 'pois' or 'nbinom'
GI_span <- 20
GI_mean <- 8
GI_var <- GI_mean + 2  # used only if GI_type='nbinom'

# Calendar times where the forward and 
# backward generation interval distributions
# will be calculated:
cal.times.fwdbck <- seq(GI_span-2, horizon - 4, by = 1)

# Calculate generation interval distributions:
G <- GI.resude(cal.times.fwdbck,
				R0,
				alpha,
				kappa,
				GI_span,
				GI_mean,
				GI_var,
				GI_type,
				horizon,
				pop_size = pop_size,
				I.init = I.init)

# Retrieve results:
gi <- G$intrinsic
gbck <- G$bck
gfwd <- G$fwd


###  PLOTS  ###

par(mfrow=c(1,1)) 

# Epidemic time series
plot(G$susceptible,
	 xlab = 'calendar time', ylab='', 
	 main='Number of susceptibles',
	 typ='l')
grid()
plot(G$incidence,typ='l',
	 xlab = 'calendar time', ylab='', 
	 main = 'Incidence')
grid()

# GI Distributions:
plot(x=gi$tsi, y=gi$density,
	 main = 'Backward GI distributions\n at requested calendar times',
	 xlab = 'time since infection', ylab='',yaxt='n',
	 ylim = c(0,1.2*max(gi$density)),
	 pch=16)
for(i in 1:length(cal.times.fwdbck)){
	gb <- gbck$density[[i]]
	lines(x = gbck$tsi[1:length(gb)], y = gb, typ='l', col = rgb(0,0,1,0.2))
}
legend(x='topright',lwd = c(1,0),legend = c('backward','intrinsic'),pch=c(NA,16))

plot(x=gi$tsi, y=gi$density,
	 main = 'Forward GI distributions\n at requested calendar times',
	 xlab = 'time since infection', ylab='',yaxt='n',
	 ylim = c(0,1.2*max(gi$density)),
	 pch=16)
for(i in 1:length(cal.times.fwdbck)){
	lines(x = gfwd$tsi, y = gfwd$density[[i]], typ='l', col=rgb(0,.5,0,0.1))
}
legend('topright',lwd = c(1,0),legend = c('forward','intrinsic'),pch=c(NA,16))


plot(x=cal.times.fwdbck, y=G$fwd.mean, 
	 xlim = c(0,horizon),
	 main = 'Mean of the forward GI distribution\n at requested calendar times',
	 xlab = 'calendar time', ylab='', 
	 las = 1,
	 typ='o')
abline(h=GI_mean, lty=2)
grid()
plot(x=cal.times.fwdbck, y=G$bck.mean, 
	 xlim = c(0,horizon),
	 main = 'Mean of the forward GI distribution\n at requested calendar times',
	 xlab = 'calendar time', ylab='', 
	 las = 1,
	 typ='o')
abline(h=GI_mean, lty=2)
grid()
```





## Contact-tracing data example

In an epidemic investigation of an on-going outbreak, contact tracing typically provides _backward_ generation interval: an infectee was infected at time $t_1$ and her identified infector was infected at time $t_0$. The backward generation interval is simply $t_1-t_0$.
Hence, for a mathematical model used to analyze this outbreak, if contact tracing data is available and the modeller is willing to fit this model to such data, it is important to fit the _backward_ generation interval (not the intrinsic, as may happen with a naive approach).

First, let's assume we want to work with a RESuDe model that we want to fit to generation intervals collected from an epidemiological investigation. As mentioned above, these intervals are typically calculated backward in time.

Let's setup these observed generation intervals:
```{r}
# Calendar times when the GI were observed:
t.obs <- c(6,7,10,21,25,40,40,45,47,47,47,47,55,59,59,59)
# GI at the associated calendar times:
gi.obs <- c(5,6,8,9,10,7,9,9,11,9,10,11,11,10,11,12)
```

Now, we setup the model. For this simple example, assume the _intrinsic_ generation interval is Poisson distributed and there is no heterogeneous mixing ($\alpha=0$) and no interventions modelled ($\kappa=0$). We want to fit $\mathcal{R}_0$ and the mean of the intrinsic generation interval to the observed data.
Thus, we have to calculate the _backward_ generation interval distributions at the observation times and match, for example, its mean to the data. Here, we'll just use a least-square approach to keep things simple for this vignette, but more elaborate fitting techniques (with likelihood for example) are warranted.

Define the error function to minimize
```{r}
err.fct <- function(x, t.obs, gi.obs) {
	R0 <- x['R0']
	m  <- x['gimean']
	tu <- unique(t.obs)
	
	G <- GI.resude(cal.times.fwdbck = tu,
				R0,
				alpha = 0,
				kappa = 0,
				GI_span = 20,
				GI_mean = m,
				GI_var = NA,
				GI_type = 'pois',
				horizon = 200)

	gbckmean <- G$bck.mean 
	
	dat.obs <- ddply(data.frame(t.obs,gi.obs),"t.obs", summarize, m=mean(gi.obs),n=length(gi.obs))
	# error is weighted by the number of observations:
	err <- sqrt(sum( dat.obs$n * (gbckmean - dat.obs$m)^2 )/sum(dat.obs$n))
}
```

Now run a minimizer on this function in order to find the best values that fit the data:
```{r}
fit <- optim(par = c(R0=2, gimean=9),  # starting values
			 fn = err.fct,
			 t.obs=t.obs, gi.obs=gi.obs)
# Fitted parameters:
fitted.prm <- fit$par
print(fitted.prm)
```

Finally, let's visually check how good the fit is:
```{r,fig.width=7, fig.height=6}
tu <- unique(t.obs)
Gfit <- GI.resude(cal.times.fwdbck = tu,
				R0 = fitted.prm['R0'],
				alpha = 0,
				kappa = 0,
				GI_span = 20,
				GI_mean = fitted.prm['gimean'],
				GI_var = NA,
				GI_type = 'pois',
				horizon = 200)

gbck.fit <- Gfit$bck.mean

plot(x = tu, y = gbck.fit, 
	 ylim = range(gbck.fit,gi.obs),
	 typ='o', pch=16,lwd=3,
	 las = 1, xlab = 'calendar time', ylab='days',
	 main = 'RESuDe model fitted to contact tracing data')
points(t.obs, gi.obs, pch=3, col='red',lwd=6,cex=2)
grid()
legend('topleft', legend = c('data','model fit'),col=c('red','black'),pch=c(3,16),lwd=c(NA,3),pt.cex = c(1,1), pt.lwd = c(6,1))
```






